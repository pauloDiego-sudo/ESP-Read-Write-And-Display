#include <driver/gpio.h>
#include <driver/spi_master.h>
#include <esp_log.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h> 
#include <stdio.h> //include the standard input/output library
#include <string.h> //include the string library
#include <u8g2.h> //include the u8g2 library

#include "sdkconfig.h" //generated by the build system
#include "u8g2_esp32_hal.h" //hardware abstraction layer for the u8g2 library
#include "bitmap.h" //bitmap file (with the array of the bitmap in XBM format)
#include "esp_spiffs.h" //spiffs library

#include <sys/unistd.h> //standard symbolic constants and types
#include <sys/stat.h> //data returned by the stat() function
#include "esp_err.h" //error codes
#include "esp_log.h" //log library
#include "driver/gpio.h"
#include "driver/sdmmc_host.h"
#include "driver/sdmmc_defs.h"
#include "sdmmc_cmd.h"
#include "esp_vfs_fat.h"

// CLK - GPIO14
#define PIN_CLK 14

// MOSI - GPIO 13
#define PIN_MOSI 13

// RESET - GPIO 26
#define PIN_RESET 26

// DC - GPIO 27
#define PIN_DC 27

// CS - GPIO 15
#define PIN_CS 15
static char tag[] = "test_SSD1306";
static const char *TAG = "spiffs_Example";

u8g2_t u8g2;

void esp_spiffs_config(void){
    ESP_LOGI(TAG, "Initializing SPIFFS");

    esp_vfs_spiffs_conf_t conf = {
      .base_path = "/spiffs",
      .partition_label = NULL,
      .max_files = 5,
      .format_if_mount_failed = true
    };

    esp_err_t ret = esp_vfs_spiffs_register(&conf);

    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "Failed to mount or format filesystem");
        } else if (ret == ESP_ERR_NOT_FOUND) {
            ESP_LOGE(TAG, "Failed to find SPIFFS partition");
        } else {
            ESP_LOGE(TAG, "Failed to initialize SPIFFS (%s)", esp_err_to_name(ret));
        }
        return;
    }
    
    size_t total = 0, used = 0;
    ret = esp_spiffs_info(conf.partition_label, &total, &used);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get SPIFFS partition information (%s). Formatting...", esp_err_to_name(ret));
        esp_spiffs_format(conf.partition_label);
        return;
    } else {
        ESP_LOGI(TAG, "Partition size: total: %d, used: %d", total, used);
    }

    if (used > total) {
        ESP_LOGW(TAG, "Number of used bytes cannot be larger than total. Performing SPIFFS_check().");
        ret = esp_spiffs_check(conf.partition_label);
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "SPIFFS_check() failed (%s)", esp_err_to_name(ret));
            return;
        } else {
            ESP_LOGI(TAG, "SPIFFS_check() successful");
        }
    }
}

void spiffs_read_file_and_display(char path[]){
    ESP_LOGI(TAG, "Reading file");
    FILE* f = fopen(path, "r");
    if (f == NULL) {
        ESP_LOGE(TAG, "Failed to open file for reading");
        return;
    }
    char line[64];
    
    //OLED display
    // u8g2_ClearBuffer(&u8g2);
    u8g2_SetFont(&u8g2, u8g2_font_ncenB14_tr);

    while (fgets(line, sizeof(line), f)) {
        ESP_LOGI(TAG, "Read from file: '%s'", line);
        //Display the content of the file at the OLED
        u8g2_ClearBuffer(&u8g2);
        u8g2_DrawStr(&u8g2, 0, 30,line);
        u8g2_SendBuffer(&u8g2);
        vTaskDelay(3000 / portTICK_PERIOD_MS);
    }
    fclose(f);
}

void oled_spi_config_and_init(void){
  u8g2_esp32_hal_t u8g2_esp32_hal = U8G2_ESP32_HAL_DEFAULT;
  u8g2_esp32_hal.bus.spi.clk = PIN_CLK;
  u8g2_esp32_hal.bus.spi.mosi = PIN_MOSI;
  u8g2_esp32_hal.bus.spi.cs = PIN_CS;
  u8g2_esp32_hal.dc = PIN_DC;
  u8g2_esp32_hal.reset = PIN_RESET;
  u8g2_esp32_hal_init(u8g2_esp32_hal);

  // a structure which will contain all the data for one display
  u8g2_Setup_ssd1306_128x64_noname_f(
      &u8g2, U8G2_R0, u8g2_esp32_spi_byte_cb,
      u8g2_esp32_gpio_and_delay_cb);  // init u8g2 structure

  u8g2_InitDisplay(&u8g2);  // send init sequence to the display, display is in
                            // sleep mode after this,
  u8g2_SetPowerSave(&u8g2,0);  // wake up display
}

void display_bitmap(const int frames_quantity, const uint8_t* bitmap[], u8g2_int_t x, u8g2_int_t y, u8g2_int_t w, u8g2_int_t h){
  for(int i=0;i<frames_quantity;i++){
    u8g2_ClearBuffer(&u8g2);
    u8g2_DrawXBM(&u8g2, x,y, w, h, bitmap[i]);
    u8g2_SendBuffer(&u8g2);
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
  u8g2_ClearBuffer(&u8g2);
}


void app_main(void) {
    oled_spi_config_and_init();
    esp_spiffs_config();

    spiffs_read_file_and_display("/spiffs/test.txt");
    
    for(;;){
        display_bitmap(reddit_robot_bitmap_allArray_LEN,reddit_robot_bitmap_allArray,40,10,50,50);
    }

    ESP_LOGD(tag, "All done!");
    vTaskDelete(NULL);
}